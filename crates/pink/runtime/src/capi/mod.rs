use pink_capi::v1;
use v1::*;

use phala_sanitized_logger as logger;

pub(crate) use ocall_impl::OCallImpl;

// This makes sure the type of __pink_runtime_init matches init_t.
const _: init_t = Some(__pink_runtime_init);

/// This is the entry point of the runtime. It will initialize the runtime and
/// fill the ecalls table.
///
/// # Safety
///
/// The caller should make sure the pointers are valid and non-null.
#[no_mangle]
pub unsafe extern "C" fn __pink_runtime_init(
    config: *const config_t,
    ecalls: *mut ecalls_t,
) -> ::core::ffi::c_int {
    let config = unsafe { &*config };
    if let Err(err) = ocall_impl::set_ocall_fn(config.ocalls) {
        log::error!("Failed to init runtime: {err}");
        return -1;
    }
    if ecalls.is_null() {
        log::error!("Failed to init runtime: ecalls is null");
        return -1;
    }
    unsafe {
        (*ecalls).ecall = Some(ecall);
        (*ecalls).get_version = Some(get_version);
    }
    if config.is_dylib != 0 {
        logger::init_subscriber(config.enclaved != 0);
    }
    0
}

unsafe extern "C" fn get_version(major: *mut u32, minor: *mut u32) {
    let ver = crate::version();
    *major = ver.0;
    *minor = ver.1;
}

/// This function serves as the central hub for all 'ecall' functions.
///
/// Upon invocation, it routes function calls by invoking the `ecall::dispatch` which is
/// auto-generated by the proc macro to `ECallImpl`, the entity implementing the `ECalls` trait.
///
/// # Safety
/// This is an `unsafe` function as it involves raw pointer interaction.
///
/// # Arguments
/// * `call_id`: A unique identifier for the function call matching the id defined in the trait ECalls.
/// * `data`: A pointer to the input data buffer where the SCALE encoded arguments stores.
/// * `len`: The size of the input data buffer.
/// * `ctx`: A mutable pointer to the context which is an opaque pointer that would be passed to the output_fn.
/// * `output_fn`: Function pointer to receive the SCALE encoded function return value.
unsafe extern "C" fn ecall(
    call_id: u32,
    data: *const u8,
    len: usize,
    ctx: *mut ::core::ffi::c_void,
    output_fn: output_fn_t,
) {
    let input = unsafe { std::slice::from_raw_parts(data, len) };
    let output = ecall::dispatch(
        &mut ecall_impl::storage(),
        &mut ecall_impl::ECallImpl,
        call_id,
        input,
    );
    if let Some(output_fn) = output_fn {
        unsafe { output_fn(ctx, output.as_ptr(), output.len()) };
    }
}

mod ecall_impl;
mod ocall_impl;
